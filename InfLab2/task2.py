import numpy as np

# Рабочие формулы

# Поиск определителя
def opr(A):
    # Глубокое копирование исходной матрицы
    C = np.copy(A)
    C = C.astype('float64')

    #  Коэффициент, стоящий перед матрицей
    K = 1

    # Цикл 1
    for j in range(len(C)-1):
        # Устранение нулей на главной диагонали
        i = j + 1
        # Вложенный цикл 1
        while C[j, j] == 0:
            C[j:j+1] += C[i:i+1]
            i += 1
        
        # Вынос элемента на главной диагонали за определитель
        K *= C[j, j]

        # Формирование единицы на главной диагонали
        C[j:j+1] = C[j:j+1]*(1/C[j, j])

        # Обнуление элементов под главной диагональю
        # Вложенный цикл 2
        for i in range(j+1, len(C)):
            C[i:i+1] += -(C[j:j+1])*C[i, j]
        
    # Элемент в правом нижнем углу является определителем
    return K*C[len(C)-1, len(C)-1]

# Поиск обратной матрицы
def obr(A):
    # Задание матрицы алгебраических дополнений
    C = np.zeros((len(A), len(A)), dtype='float64')

    # Заполнение матрицы алгебраических дополнений
    # Цикл 1
    for i in range(len(C)):
        # Вложенный цикл 1
        for j in range(len(C)):
            # Расчёт дополнительного минора
            M = np.delete(A, i, 0)
            M = np.delete(M, j, 1)
            m = opr(M)

            # Заполнений i, j-го элемента матрицы алгебраических дополнений
            C[i, j] = np.power(-1, i+j) * m

    return (1/opr(A))*np.transpose(C)

# Задание условий задачи

R1 = 1
R2 = 1
R3 = 5
R4 = 4
R5 = 1
R6 = 1

E1 = 1
E2 = 1
E3 = 1

# Задание матрицы коэффициентов
A = np.array([
    [0, -1, 1, 0, 0, -1],
    [0, 1, 0, -1, 1, 0],
    [-1, 0, -1, 0, -1, 0],
    [0, -R4, -R3, 0, R5, 0],
    [0, -R4, 0, R1, 0, R6],
    [R2, 0, 0, R1, R5, 0]
])

# Задание матрицы свободных членов
B = np.array([
    [0],
    [0],
    [0],
    [0],
    [-E1-E2],
    [E1+E3]
])

# Поиск решений
X = obr(A) @ B
print(X)